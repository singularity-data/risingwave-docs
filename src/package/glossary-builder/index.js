const fs = require("fs");
const path = require("path");

const GLOSSARY_PATH = path.resolve(process.cwd(), "docs", "glossary");
const CATEGORY_PATH = path.resolve(process.cwd(), "docs", "glossary.md");

const handleGlossaryFile = (pathname) => {
  let str = fs.readFileSync(pathname).toString();
  let headerMatch = str.match(/---(.|\n)*---/);
  if (!headerMatch) {
    console.error(`${path.basename(pathname)} contain no header.
      The format of the header should be ---<header content>---.`);
    return;
  }
  let titleMatch = headerMatch[0].match(/title:.*/);
  if (!titleMatch) {
    console.error(`${path.basename(pathname)} contain no title in the header.
      Please specify title. e.g. title: xxx`);
    return;
  }
  let title = titleMatch[0].split(":")[1].trim();
  // Get the glossary content
  let content = str.slice(headerMatch[0].length, str.length);
  let glossaryContentMatch = content.match(/(?<=<!--[ ]*glossary[ ]*-->)(.|\n)*(?=<!--[ ]*end[ ]*glossary[ ]*-->)/);
  let glossaryContent;
  if (!glossaryContentMatch) {
    glossaryContent = "";
  } else {
    glossaryContent = glossaryContentMatch[0].trim();
  }
  return {
    title,
    content: glossaryContent
  }
};

const generateMetadata = (pathname) => {
  let rtn = {};
  if (!fs.existsSync(pathname)) {
    return;
  }
  if (fs.lstatSync(pathname).isDirectory()) {
    for (let nextPathname of fs.readdirSync(pathname)) {
      rtn = { ...rtn, ...generateMetadata(path.resolve(pathname, nextPathname)) };
    }
  } else { // is file
    let { title, content } = handleGlossaryFile(pathname);
    rtn[title] = content;
  }
  return rtn;
};

const generateCategory = (metadata) => {
  let alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split('');
  let p = 0; // interator of alphabet

  let mapper = new Map();
  alphabet.forEach(x => mapper.set(x, []));

  let keys = Object.keys(metadata).sort();
  for (let key of keys) {
    while (alphabet[p] !== key.charAt(0).toUpperCase()) {
      ++p;
    }
    mapper.get(alphabet[p]).push(key);
  }

  let rtn =
    "---\n" +
    "id: glossary\n" +
    "title: glossary\n" +
    "slug: /glossary\n" +
    "---\n" +
    "<!-- This document is generated by Glossary Builder. You should not change the content of this page  -->\n" + 
    "\n" +
    "import GlossaryTip from \"@site/src/components/GlossaryTip\";\n\n";
  alphabet.forEach(x => {
    if (mapper.get(x).length !== 0) {
      rtn += `## ${x}\n\n`;
      mapper.get(x).sort().forEach(term => {
        rtn += `<GlossaryTip title="${term}" />\n\n`;
      })
    }
  });

  return rtn;
};

// generate metadata
const metadata = generateMetadata(GLOSSARY_PATH);
console.log(`[Glossary Builder] ${Object.keys(metadata).length} termininologies found in glossary folder.`);

// store metadata for GlossaryTip
const GROSSORY_COMPONENT_PATH = path.resolve(process.cwd(), "src", "components", "GlossaryTip", "metadata.json");
fs.writeFileSync(GROSSORY_COMPONENT_PATH, JSON.stringify(metadata, null, 2));

// generate category `Glossary.md`
fs.writeFileSync(CATEGORY_PATH, generateCategory(metadata));

